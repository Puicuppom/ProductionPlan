<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>แผนผลิต – Production Planner (Supabase v4.2.8)</title>
  <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@300;400;600;700&display=swap" rel="stylesheet"/>
  <!-- Library สำหรับสร้างไฟล์ XLSX -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <!-- Supabase Client Library -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    :root{ --primary:#2563eb; --muted:#6b7280; --bg:#f7fafc; --card:#fff; --border:#e5e7eb; --ink:#111827 }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;font-family:"Sarabun",system-ui,-apple-system,Segoe UI,Roboto;background:var(--bg);color:var(--ink)}
    header{position:sticky;top:0;z-index:5;background:#fff;border-bottom:1px solid var(--border)}
    header .bar{display:flex;gap:12px;align-items:center;justify-content:space-between;padding:12px 16px;max-width:1200px;margin:0 auto}
    h1{font-size:20px;margin:0}
    .wrap{max-width:1200px;margin:16px auto;padding:0 16px 80px; transition: max-width 0.3s ease-in-out;}
    .wrap-dashboard { max-width: 100%; padding: 0 24px 80px; }
    .grid{display:grid;gap:12px}
    .g-2{grid-template-columns:repeat(2,minmax(0,1fr))}
    .g-3{grid-template-columns:repeat(3,minmax(0,1fr))}
    .grid-2-1{grid-template-columns:2fr 1fr}
    @media (max-width:980px){.g-2,.g-3,.grid-2-1{grid-template-columns:1fr}}
    .card{background:var(--card);border:1px solid var(--border);border-radius:14px;box-shadow:0 2px 10px rgba(0,0,0,.04)}
    .card h2,.card h3{margin:0 0 8px;padding:12px 14px;border-bottom:1px solid var(--border);font-size:18px}
    .card .inner{padding:12px 14px}
    label{font-size:13px;color:var(--muted);display:block;margin-bottom:2px;}
    input,select{width:100%;padding:10px 12px;border:1px solid var(--border);border-radius:10px;background:#fff}
    .row{display:grid;grid-template-columns:160px 1fr;gap:10px;align-items:center}
    .row+.row{margin-top:8px}
    .btn{appearance:none;border:1px solid var(--primary);background:var(--primary);color:#fff;padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:600}
    .btn.secondary{background:#fff;color:var(--primary)}
    .btn.gray{background:#f3f4f6;color:#111;border-color:#e5e7eb}
    .btn.danger{background:#ef4444;border-color:#ef4444;color:#fff}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .btn.active{outline:2px solid var(--primary);box-shadow:0 0 0 3px rgba(37,99,235,.15)}
    .badge{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border-radius:999px;font-size:12px;border:1px solid var(--border);background:#fff}
    .list{display:flex;flex-direction:column;gap:10px;min-height:60px;}
    .job{border:1px solid var(--border);border-radius:12px;background:#fff;padding:10px; transition: background-color 0.3s, border-color 0.3s;}
    .job.dragging{opacity:0.5;border-style:dashed;}
    .jobhead{display:flex;gap:10px;align-items:center;padding-bottom:8px;border-bottom:1px solid var(--border);}
    .drag{cursor:grab;user-select:none;font-size:18px;line-height:1;padding:2px 8px}
    .job .title{font-weight:700}
    .job small{color:var(--muted)}
    .procwrap{padding:10px 0 0}
    .proc{border:1px dashed var(--border);border-radius:12px;padding:8px;background:#fdfdfd}
    .proc+.proc{margin-top:6px;}
    .proc h4{margin:0 0 4px;font-size:14px}
    .proc .grid2{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:6px}
    .proc .timebox{display:grid;grid-template-columns:auto 1fr;gap:6px;align-items:center}
    .proc .act{display:flex;gap:6px;flex-wrap:wrap;margin-top:6px;}
    .proc .act .btn{padding:6px 10px;border-radius:10px;font-size:12px}
    .rowcols{display:grid;grid-template-columns:repeat(auto-fill, minmax(140px, 1fr));gap:8px}
    .rowcols>div{display:flex;flex-direction:column;gap:6px}
    table{width:100%;border-collapse:separate;border-spacing:0}
    th,td{padding:8px 10px;border-bottom:1px solid var(--border);text-align:left;vertical-align: top;}
    th{font-size:12px;color:#374151;background:#f9fafb;position:sticky;top:0; white-space: nowrap;}
    .dept-divider { border-left: 2px solid #dde4ed; }
    .cut-time-divider { border-left: 2px solid #dde4ed; }
    tr:hover td{background:#fafafa}
    tr.dragging td { background: #ebf8ff; border-top: 2px solid var(--primary); border-bottom: 2px solid var(--primary); }
    .drag-handle { cursor: grab; padding-right: 10px; font-size: 16px; color: #9ca3af; }
    .footerbar{position:fixed;left:0;right:0;bottom:0;background:#fff;border-top:1px solid var(--border);padding:8px 12px;display:flex;gap:8px;justify-content:center}
    .hidden{display:none}
    .help{font-size:12px;color:var(--muted)}
    .pill{padding:4px 8px;border-radius:999px;border:1px solid var(--border); font-size:12px; background:#f9fafb;}
    .right{margin-left:auto}
    .inline{display:inline-flex;gap:6px;align-items:center}
    .mini{padding:4px 8px;font-size:12px;border-radius:8px}
    .toolbar{display:flex;gap:8px;align-items:end;flex-wrap:wrap;margin-bottom:12px}
    input::placeholder{ color:#9ca3af }
    .toggle{margin-left:auto}
    .dept-board{ display: grid; gap: 16px; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); }
    .line-container{ padding: 12px; border: 1px solid var(--border); border-radius: 12px; background: #f9fafb; }
    .line-container h3{ margin: 0 0 10px; font-size: 16px; border-bottom: 1px solid var(--border); padding-bottom: 8px; }
    .line-assign-select { font-size: 12px; padding: 4px 6px; border-radius: 8px; min-width: 85px; }
    .qty-pills-container { display: flex; flex-wrap: wrap; gap: 4px; align-items: center; }
    .status-cell { display: flex; flex-direction: column; align-items: start; gap: 4px; }
    .nav-group { display: inline-flex; border: 1px solid var(--border); border-radius: 12px; overflow: hidden; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
    .nav-group .btn { flex: 1; text-align: center; background: #fff; color: var(--ink); border: none; border-radius: 0; border-left: 1px solid var(--border); font-weight: 600; padding: 8px 16px; }
    .nav-group .btn:first-child { border-left: none; }
    .nav-group .btn.active, .nav-group .btn:hover { background: var(--primary); color: #fff; z-index: 1; }
    .nav-group .btn.active { box-shadow: inset 0 2px 4px rgba(0,0,0,0.1); }
    .status-badge { display: inline-block; padding: 3px 10px; border-radius: 999px; font-weight: 600; font-size: 12px; border: 1px solid transparent; background-color: #f3f4f6; color: #374151; border-color: #e5e7eb; }
    .status-badge.status-progress { background-color: #e0f2fe; color: #0c4a6e; border-color: #bae6fd; }
    .status-badge.status-done { background-color: #dcfce7; color: #166534; border-color: #bbf7d0; }
    tr.status-row-progress td { background-color: #f0f9ff !important; }
    tr.status-row-done td { background-color: #f0fdf4 !important; }
    .job.job-card-progress { background-color: #f0f9ff; border-color: #bae6fd; }
    .job.job-card-done { background-color: #f0fdf4; border-color: #bbf7d0; }
    .checkbox-cell { width: 40px; text-align: center; }
    tr.row-selected td { background-color: #fffbeb !important; }
    .plan-time-hint { color: #9ca3af; font-weight: normal; font-size: 11px; }
  </style>
</head>
<body>
  <header>
    <div class="bar">
      <div style="display:flex;align-items:center;gap:10px">
        <h1>แผนผลิต (Production Planner)</h1>
        <span class="badge">เวอร์ชัน: 4.2.8 • Supabase DB</span>
      </div>
      <div class="nav-group">
        <button class="btn" id="btnDashboard">Dashboard (Master Plan)</button>
        <button class="btn" id="btnDepartments">หน้าแผนก (คิวงาน)</button>
        <button class="btn" id="btnJobs">ใบงานทั้งหมด</button>
        <button class="btn" id="btnNewJob">สร้าง/แก้ไขใบงาน</button>
        <button class="btn" id="btnSettings">ตั้งค่า</button>
      </div>
      <div style="display:flex;gap:6px;align-items:center;" class="right">
        <input id="pass" type="password" placeholder="รหัสผ่าน" style="width:120px;padding:6px 10px;font-size:12px;">
        <button class="btn mini" id="btnUnlock">ปลดล็อก</button>
        <span class="badge">สถานะ: <b id="lockState">ปิด</b></span>
      </div>
    </div>
  </header>

  <div class="wrap">
    <!-- 1) Job Form (Create / Edit) -->
    <section class="card hidden" id="viewForm">
      <h2>1) สร้าง/แก้ไข ใบงาน</h2>
      <div class="inner">
        <div class="grid g-3">
          <div><label>วันที่</label><input type="date" id="f_date"></div>
          <div><label>ชื่อใบงาน</label><input type="text" placeholder="เช่น SPTR 24-09 R1" id="f_name"></div>
          <div><label>เวลาตัดใบงาน</label><input type="time" id="f_cut"></div>
        </div>
        <div id="qtyGrid" class="rowcols" style="margin-top:10px"></div>
        <div style="display:flex;gap:8px;margin-top:12px;align-items:center;flex-wrap:wrap">
          <button class="btn" id="btnAddJob">เพิ่มใบงาน</button>
          <button class="btn" id="btnSaveJob" style="display:none">บันทึกการแก้ไข</button>
          <button class="btn gray" id="btnCancelEdit" style="display:none" type="button">ยกเลิก</button>
          <button class="btn gray" id="btnClearForm" type="button">ล้างแบบฟอร์ม</button>
          <span class="help right">* ปริมาณ 0 หมายถึงไม่ลงคิวในแผนกนั้น</span>
        </div>
        <hr style="border-color: var(--border); border-style: dashed; margin: 16px 0;">
        <div style="display:flex;gap:8px;align-items:center;">
            <label style="margin:0; font-weight:bold;">นำเข้า/ส่งออก ใบงาน:</label>
            <button class="btn gray mini" id="btnDownloadTemplateXLSX">Download Template (.xlsx)</button>
            <label class="btn gray mini" style="cursor:pointer;">Upload ใบงาน (.xlsx)<input type="file" id="fileImportJobsXLSX" class="hidden" accept=".xlsx, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"></label>
        </div>
      </div>
    </section>

    <!-- 2) Jobs List -->
    <section class="card hidden" id="viewJobs">
      <h2>2) ใบงานทั้งหมด (ค้นหา/แก้ไข/ลบ)</h2>
      <div class="inner">
        <div class="toolbar">
          <div><label>เลือกวัน</label><select id="j_date"></select></div>
          <div><label>ค้นหาชื่อ</label><input type="text" id="j_search" placeholder="พิมพ์บางส่วนของชื่อ" style="width:260px;"></div>
          <button class="btn gray" id="j_clear">ล้างตัวกรอง</button>
          <div class="right">
            <button class="btn danger hidden" id="j_deleteSelected">ลบรายการที่เลือก (0)</button>
          </div>
        </div>
        <div class="tablewrap" style="overflow-x:auto;max-height:520px;border:1px solid var(--border);border-radius:12px">
          <table id="tableJobs"><thead><tr>
            <th class="checkbox-cell"><input type="checkbox" id="j_selectAll"></th>
            <th style="min-width:160px">ชื่อใบงาน</th>
            <th>วันที่</th>
            <th>เวลาตัด</th>
            <th>จำนวนต่อแผนก</th>
            <th style="min-width:160px">จัดการ</th>
          </tr></thead><tbody></tbody></table>
        </div>
      </div>
    </section>

    <!-- 3) Department Boards -->
    <section class="card hidden" id="viewDepartments">
      <h2>3) หน้าแผนก (คิวงานตาม Master Plan)</h2>
      <div class="inner">
        <div class="toolbar">
          <div><label>เลือกวัน</label><input type="date" id="dep_date"></div>
          <div><label>เลือกแผนก</label><select id="dep_filter" style="width:220px;"></select></div>
        </div>
        <div id="deptBoards"></div>
      </div>
    </section>

    <!-- 4) Dashboard -->
    <section class="card" id="viewDashboard">
      <h2>4) Dashboard & Master Plan (ลากเพื่อจัดลำดับ, เลือกไลน์)</h2>
      <div class="inner">
        <div class="toolbar">
          <div><label>เลือกวัน</label><input type="date" id="d_date"></div>
          <button class="btn gray right" id="btnDownloadXLSX">Download Excel (แยกแผนก)</button>
        </div>
        <div class="help" style="margin:6px 0 12px;">* เวลาแผนจะอัปเดตตาม "เวลาเสร็จจริง" ของงานก่อนหน้า และข้าม "เวลาพัก" ของแต่ละแผนกโดยอัตโนมัติ</div>
        <div id="kpiBar" style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px;"></div>
        <div class="tablewrap" style="overflow-x:auto;max-height:60vh;border:1px solid var(--border);border-radius:12px">
          <table id="tableDash">
            <thead></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </section>

    <!-- Settings -->
    <section class="card hidden" id="viewSettings">
      <h2>ตั้งค่า (แผนก • กระบวนการ • เวลามาตรฐาน)</h2>
      <div class="inner">
        <div class="grid grid-2-1">
            <div class="card" style="border-style:dashed">
              <h3 style="padding:12px 14px;border:0; margin:0">แผนก (เพิ่ม/ลบ/เปลี่ยนชื่อ/จัดลำดับ)</h3>
              <div id="deptManager" style="margin-top:8px; padding:0 14px 14px;"></div>
              <div style="padding:0 14px 14px;"><button class="btn mini" id="btnAddDept" style="margin-top:8px;">+ เพิ่มแผนก</button></div>
            </div>
            <div class="card" style="border-style:dashed">
                <h3 style="padding:12px 14px;border:0; margin:0">เวลาเริ่ม-เลิกงาน Default</h3>
                <div class="grid g-2" style="margin-top:10px; padding:0 14px 14px;">
                    <div><label>เวลาเริ่มงาน</label><input type="time" id="s_dayStart"></div>
                    <div><label>เวลาเลิกงาน</label><input type="time" id="s_dayEnd"></div>
                </div>
            </div>
        </div>

        <div class="toolbar" style="margin-top:16px; margin-bottom:4px;">
            <label style="font-weight:bold; font-size:18px; margin:0;">ตั้งค่ารายละเอียดแผนก:</label>
            <select id="deptSel" style="width:220px;display:inline-block;vertical-align:middle;padding:8px;"></select>
        </div>
        <div class="card" style="margin-top:12px;">
            <div class="inner">
                <div class="grid">
                    <div>
                        <h4 style="margin:0 0 8px;">ขั้นตอนของแผนก</h4>
                        <div id="procEditor"></div>
                        <button class="btn mini" id="btnAddProc" style="margin-top:8px;">+ เพิ่มขั้นตอน</button>
                    </div>
                </div>
                <hr style="border-color: var(--border); border-style: dashed; margin: 16px 0;">
                <div class="grid g-2">
                    <div>
                        <h4 style="margin:12px 0 8px">เวลาเตรียมไฟล์ (นาที)</h4>
                        <div id="prepEditor"></div>
                    </div>
                    <div>
                        <h4 style="margin:12px 0 8px">จำนวนไลน์การผลิต</h4>
                        <div id="linesEditor"></div>
                    </div>
                </div>
                <hr style="border-color: var(--border); border-style: dashed; margin: 16px 0;">
                <div>
                    <h4 style="margin:0 0 8px;">ช่วงเวลาพัก (เพิ่มได้หลายช่วง)</h4>
                    <div id="breaksEditor"></div>
                    <button class="btn mini" id="btnAddBreak" style="margin-top:8px;">+ เพิ่มเวลาพัก</button>
                </div>
                <div class="right" style="display: flex; gap: 8px; align-items: center; margin-top: 16px;">
                  <button class="btn gray" id="btnExportSettingsXLSX">Export Settings (.xlsx)</button>
                  <label class="btn gray" style="cursor:pointer;">Import Settings (.xlsx)
                      <input type="file" id="fileImportSettingsXLSX" class="hidden" accept=".xlsx, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet">
                  </label>
              </div>
            </div>
        </div>
      </div>
    </section>
  </div>

  <div class="footerbar">
    <span class="pill" id="db_status">Connecting to Database...</span>
    <button class="btn gray" id="btnClearAll" disabled>ล้างข้อมูลทั้งหมด</button>
  </div>

<script>
// --- SUPABASE SETUP ---
const SUPABASE_URL = 'https://qdbdjpnhvismdkavjvtg.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFkYmRqcG5odmlzbWRrYXZqdnRnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTkxMTYzMDYsImV4cCI6MjA3NDY5MjMwNn0.hjxzh8z-SBmSlEQ1RXCvmHgpL1JWzYXLj43q6BrIDkQ';
const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
// --- END SUPABASE SETUP ---

const LOCK_PASS = 'TRkids@999';
let currentDeptSel = null;
let editingJobId = null;
let currentView = 'dash';
let unlocked = false;
let isDragging = false; // Flag to control realtime updates during drag

const ui = { expand: {} };
function isExpanded(dept, jobId){ return !!(ui.expand[dept] && ui.expand[dept][jobId]); }
function setExpanded(dept, jobId, val){ (ui.expand[dept] || (ui.expand[dept] = {}))[jobId] = !!val; }

const defaultModel = () => ({
  settings:{
    dayStart:'09:30', dayEnd:'18:30',
    departments:['STAMP','STK','CTT','LASER','TUBE','PACK'],
    processes:{
      STAMP: [
        {name:'ออกแบบ', type:'per_piece', value:20},
        {name:'ยิงหน้ายาง', type:'per_piece', value:25},
        {name:'รอประกอบ', type:'fixed', value:1800},
        {name:'ประกอบ', type:'per_piece', value:60}
      ],
      STK:   [{name:'ออกแบบ', type:'per_piece', value:10}, {name:'ปริ้น', type:'per_piece', value:15}, {name:'จัดเรียง', type:'per_piece', value:10}],
      CTT:   [{name:'ออกแบบ', type:'per_piece', value:20}, {name:'ปริ้น', type:'per_piece', value:180}, {name:'จัดเรียง', type:'per_piece', value:10}],
      LASER: [{name:'ออกแบบ', type:'per_piece', value:20}, {name:'ยิง', type:'per_piece', value:60}, {name:'จัดเรียง', type:'per_piece', value:10}],
      TUBE:  [{name:'ออกแบบ', type:'per_piece', value:20}, {name:'ปริ้น', type:'per_piece', value:60}, {name:'จัดเรียง', type:'per_piece', value:10}],
      PACK:  [{name:'ทำใบปะหน้า', type:'per_piece', value:20}, {name:'แพ็ค', type:'per_piece', value:60}]
    },
    prepPerJob:{ STAMP:10, STK:10, CTT:10, LASER:10, TUBE:10, PACK:10 },
    deptBreaks:{
        STAMP: [{start:'13:00', end:'14:00'}], STK: [{start:'13:00', end:'14:00'}], CTT: [{start:'13:00', end:'14:00'}],
        LASER: [{start:'13:00', end:'14:00'}], TUBE: [{start:'13:00', end:'14:00'}], PACK: [{start:'13:00', end:'14:00'}]
    },
    linesPerDept:{ STAMP:1, STK:1, CTT:1, LASER:1, TUBE:1, PACK:1 }
  },
  jobs:[]
});

let state = defaultModel();

// --- DATA HANDLING ---
async function saveSettings(settingsObject) {
    el('#db_status').textContent = 'Saving settings...';
    const { error } = await supabaseClient.from('settings').upsert({ id: 1, data: settingsObject }, { onConflict: 'id' });
    if (error) {
        console.error('Error saving settings:', error);
        el('#db_status').textContent = 'Error saving settings!';
        alert('เกิดข้อผิดพลาดในการบันทึกการตั้งค่า!');
    } else {
        el('#db_status').textContent = 'Database Synced';
    }
}

async function load() {
    try {
        el('#db_status').textContent = 'Loading data...';
        const { data: settingsData, error: settingsError } = await supabaseClient.from('settings').select('data').eq('id', 1).single();
        if (settingsError && settingsError.code !== 'PGRST116') throw new Error('Could not load settings.');
        const { data: jobsData, error: jobsError } = await supabaseClient.from('jobs').select('*').order('order_index');
        if (jobsError) throw new Error('Could not load jobs.');

        const loadedState = {
            settings: settingsData ? settingsData.data : defaultModel().settings,
            jobs: jobsData || []
        };

        if (!settingsData) {
            console.log('No settings found, inserting defaults...');
            await saveSettings(loadedState.settings);
        }
        
        migrateSettingsForProcessTypes(loadedState.settings);

        ensureDeptBaseline(loadedState);
        el('#db_status').textContent = 'Database Synced';
        return loadedState;
    } catch (e) {
        console.error("Critical error during load:", e);
        el('#db_status').textContent = 'DATABASE FAILED TO LOAD!';
        alert('ไม่สามารถโหลดข้อมูลจากฐานข้อมูลได้!');
        return defaultModel();
    }
}


// --- UTILITY FUNCTIONS ---
const el = sel=>document.querySelector(sel);
const cel = (tag,attrs={})=>{const n=document.createElement(tag);for(const k in attrs){if(k==='text')n.textContent=attrs[k];else if(k==='html')n.innerHTML=attrs[k];else n.setAttribute(k,attrs[k]);}return n}
const pad = n=> String(Math.floor(n)).padStart(2,'0');
const fmtTime = secs=>{ const h=Math.floor(secs/3600), m=Math.floor((secs%3600)/60); return `${h} ชม ${m} นาที`; };
const parseTimeToMin = t=>{ if(!t) return NaN; const [H,M]=t.split(':').map(Number); if(Number.isNaN(H)||Number.isNaN(M)) return NaN; return H*60+M; };
const minToHHMM = m => { const totalMinutes = Math.round(m); const hours = Math.floor(totalMinutes / 60); const minutes = totalMinutes % 60; return `${pad(hours)}:${pad(minutes)}`; };
const secToHHMM = s => minToHHMM(s/60);
const nowISO = ()=> new Date().toISOString();
const sameDay = (d1,d2)=> d1===d2;
const uid = ()=> 'J'+Math.random().toString(36).slice(2,8)+Date.now().toString(36).slice(-4);
const fmtLocalHHMM = (iso)=>{ if(!iso) return ''; const d=new Date(iso); return `${pad(d.getHours())}:${pad(d.getMinutes())}`; };

const views = { form: el('#viewForm'), dept: el('#viewDepartments'), dash: el('#viewDashboard'), set: el('#viewSettings'), jobs: el('#viewJobs') };
const navBtns = { dash: '#btnDashboard', dept: '#btnDepartments', jobs: '#btnJobs', form: '#btnNewJob', set: '#btnSettings' };

function setActive(view){ Object.values(navBtns).forEach(sel=> el(sel).classList.remove('active')); if(navBtns[view]) el(navBtns[view]).classList.add('active'); }
function show(view){
    currentView=view;
    Object.values(views).forEach(v=>v.classList.add('hidden'));
    views[view].classList.remove('hidden');
    setActive(view);
    const wrapper = el('.wrap');
    if (view === 'dash') wrapper.classList.add('wrap-dashboard');
    else wrapper.classList.remove('wrap-dashboard');
    
    if (view === 'form') {
      el('#viewForm').querySelectorAll('input, button, select').forEach(elem => {
        if (!elem.closest('.right')) elem.disabled = !unlocked;
      });
    }
}

function renderQtyGrid(){
  const host=el('#qtyGrid'); host.innerHTML='';
  state.settings.departments.forEach(d=>{
    const box=cel('div');
    box.innerHTML = `<label>${d} (ชิ้น)</label><input type="number" id="q_${d}" min="0" value="0">`;
    host.appendChild(box);
  });
}

function fillForm(job){
  el('#f_date').value = job.date;
  el('#f_name').value = job.name;
  el('#f_cut').value = job.cut || '';
  state.settings.departments.forEach(d=>{ const n=el('#q_'+d); if(n) n.value = job.qty?.[d] ?? 0; });
}
function clearForm(){ editingJobId=null; el('#btnAddJob').style.display=''; el('#btnSaveJob').style.display='none'; el('#btnCancelEdit').style.display='none'; el('#f_name').value=''; el('#f_cut').value=''; el('#f_date').value=new Date().toISOString().slice(0,10); state.settings.departments.forEach(d=>{ const n=el('#q_'+d); if(n) n.value=0; }); }

function createJobObject(data) {
    const job = { id: uid(), date: data.date, name: data.name.trim(), cut: data.cut, qty: data.qty, tracks: {}, line_assignments: {} };
    state.settings.departments.forEach(d => {
        if ((data.qty[d] || 0) > 0) {
            job.tracks[d] = { 'เตรียมไฟล์': { start: null, end: null } };
            (state.settings.processes[d] || []).forEach(p => job.tracks[d][p.name] = { start: null, end: null });
            job.line_assignments[d] = 0;
        }
    });
    return job;
}

// --- CRUD FUNCTIONS ---
async function addJob(){
    const date = el('#f_date').value; const name = el('#f_name').value.trim(); const cut = el('#f_cut').value;
    if(!date||!name){ alert('กรอก วันที่ และ ชื่อใบงาน'); return; }
    const qty = {}; state.settings.departments.forEach(d=> qty[d] = Number(el('#q_'+d)?.value || 0));
    const maxOrderIndex = state.jobs.length > 0 ? Math.max(...state.jobs.map(j => j.order_index)) : -1;
    const newJob = createJobObject({date, name, cut, qty});
    newJob.order_index = maxOrderIndex + 1;
    el('#btnAddJob').disabled = true;
    el('#db_status').textContent = 'Adding job...';
    const { error } = await supabaseClient.from('jobs').insert([newJob]);
    if(error){
        console.error('Error adding job:', error); alert('เกิดข้อผิดพลาดในการเพิ่มใบงาน');
        el('#db_status').textContent = 'Error!'; el('#btnAddJob').disabled = false; return;
    }
    state.jobs.push(newJob);
    el('#db_status').textContent = 'Database Synced';
    el('#btnAddJob').disabled = false;
    renderAll();
    clearForm();
    show('jobs');
}

async function saveJobEdit(){
    const idx = state.jobs.findIndex(j=>j.id===editingJobId); if(idx<0){ alert('ไม่พบใบงาน'); return; }
    const jobToUpdate = JSON.parse(JSON.stringify(state.jobs[idx]));
    jobToUpdate.date = el('#f_date').value;
    jobToUpdate.name = el('#f_name').value.trim();
    jobToUpdate.cut = el('#f_cut').value;
    state.settings.departments.forEach(d=>{
        jobToUpdate.qty[d] = Number(el('#q_'+d)?.value || 0);
        if(jobToUpdate.qty[d]>0){
            jobToUpdate.tracks[d] = jobToUpdate.tracks[d] || { 'เตรียมไฟล์': { start: null, end: null } };
            (state.settings.processes[d]||[]).forEach(p=>{ if(!jobToUpdate.tracks[d][p.name]) jobToUpdate.tracks[d][p.name]={start:null,end:null}; });
            if (jobToUpdate.line_assignments[d] == null) jobToUpdate.line_assignments[d] = 0;
        } else {
            delete jobToUpdate.tracks[d];
            delete jobToUpdate.line_assignments[d];
        }
    });
    el('#btnSaveJob').disabled = true;
    el('#db_status').textContent = 'Saving job...';
    delete jobToUpdate.created_at;
    const { error } = await supabaseClient.from('jobs').update(jobToUpdate).eq('id', editingJobId);
    if(error){
        console.error('Error saving job edit:', error); alert('เกิดข้อผิดพลาดในการแก้ไขใบงาน');
        el('#db_status').textContent = 'Error!'; el('#btnSaveJob').disabled = false; return;
    }
    state.jobs[idx] = jobToUpdate;
    el('#db_status').textContent = 'Database Synced';
    el('#btnSaveJob').disabled = false;
    renderAll();
    clearForm();
    show('jobs');
}

async function updateJobField(jobId, updates) {
    el('#db_status').textContent = 'Updating job...';
    const { error } = await supabaseClient.from('jobs').update(updates).eq('id', jobId);
    if (error) {
        console.error('Failed to update job:', error);
        el('#db_status').textContent = 'Update failed!';
        alert('การอัปเดตข้อมูลล้มเหลว!');
    } else {
        el('#db_status').textContent = 'Database Synced';
    }
}

function renderJobs(){
    el('#j_date').disabled = !unlocked;
    el('#j_search').disabled = !unlocked;
    el('#j_clear').disabled = !unlocked;

    const tbody = el('#tableJobs tbody'); tbody.innerHTML='';
    const qDate = el('#j_date').value; const qStr = (el('#j_search').value||'').toLowerCase();
    state.jobs
        .filter(j=> !qDate || sameDay(j.date,qDate))
        .filter(j=> !qStr || j.name.toLowerCase().includes(qStr))
        .sort((a,b)=> (b.date.localeCompare(a.date)) || (a.order_index - b.order_index))
        .forEach(j=>{
            const tr=document.createElement('tr');
            tr.innerHTML = `<td class="checkbox-cell"><input type="checkbox" class="job-checkbox" data-id="${j.id}" ${!unlocked ? 'disabled' : ''}></td>`;
            const qtyCell = cel('td');
            const qtyContainer = cel('div', { class: 'qty-pills-container' });
            state.settings.departments.forEach(d => {
                const q = j.qty?.[d] || 0;
                if (q > 0) qtyContainer.appendChild(cel('span', { class: 'pill', text: `${d}: ${q}` }));
            });
            qtyCell.appendChild(qtyContainer);
            const nameCell = cel('td', { text: j.name });
            const dateCell = cel('td', { text: j.date });
            const cutCell = cel('td', { text: j.cut || '-' });
            tr.append(nameCell, dateCell, cutCell, qtyCell);
            const tdAct = cel('td');
            tr.appendChild(tdAct);
            const bEdit = cel('button',{class:'btn mini',text:'แก้ไข'});
            const bDel = cel('button',{class:'btn mini danger',text:'ลบ'});
            bEdit.disabled = !unlocked;
            bDel.disabled = !unlocked;
            bEdit.onclick=()=>{ editingJobId=j.id; fillForm(j); el('#btnAddJob').style.display='none'; el('#btnSaveJob').style.display=''; el('#btnCancelEdit').style.display=''; show('form'); };
            bDel.onclick= async ()=>{
                if(!confirm('ลบใบงานนี้?')) return;
                el('#db_status').textContent = 'Deleting job...';
                const { error } = await supabaseClient.from('jobs').delete().eq('id', j.id);
                if (error) {
                    alert('เกิดข้อผิดพลาดในการลบ'); el('#db_status').textContent = 'Delete failed!'; return;
                }
                state.jobs = state.jobs.filter(x=>x.id!==j.id);
                el('#db_status').textContent = 'Database Synced';
                renderAll();
                show('jobs');
            };
            tdAct.append(bEdit,' ',bDel);
            tbody.appendChild(tr);
        });
    setupMultiSelectListeners();
}

function setupMultiSelectListeners() {
    const selectAll = el('#j_selectAll');
    selectAll.disabled = !unlocked;
    const deleteBtn = el('#j_deleteSelected');
    const tableBody = el('#tableJobs tbody');
    const updateDeleteButton = () => {
        const selected = document.querySelectorAll('.job-checkbox:checked');
        if (selected.length > 0 && unlocked) {
            deleteBtn.classList.remove('hidden');
            deleteBtn.textContent = `ลบรายการที่เลือก (${selected.length})`;
        } else {
            deleteBtn.classList.add('hidden');
        }
    };
    tableBody.addEventListener('click', (e) => {
        if (e.target.classList.contains('job-checkbox')) {
            const tr = e.target.closest('tr');
            tr.classList.toggle('row-selected', e.target.checked);
            updateDeleteButton();
        }
    });
    selectAll.addEventListener('change', () => {
        document.querySelectorAll('.job-checkbox').forEach(cb => {
            cb.checked = selectAll.checked;
            cb.closest('tr').classList.toggle('row-selected', selectAll.checked);
        });
        updateDeleteButton();
    });
    deleteBtn.onclick = async () => {
        const selected = document.querySelectorAll('.job-checkbox:checked');
        if (selected.length === 0 || !confirm(`คุณแน่ใจหรือไม่ว่าต้องการลบ ${selected.length} รายการที่เลือก?`)) return;
        const idsToDelete = Array.from(selected).map(cb => cb.dataset.id);
        el('#db_status').textContent = `Deleting ${idsToDelete.length} jobs...`;
        const { error } = await supabaseClient.from('jobs').delete().in('id', idsToDelete);
        if(error) {
            alert('เกิดข้อผิดพลาดในการลบ'); el('#db_status').textContent = 'Delete failed!'; return;
        }
        state.jobs = state.jobs.filter(job => !idsToDelete.includes(job.id));
        el('#db_status').textContent = 'Database Synced';
        renderJobs();
    };
    updateDeleteButton();
}

// --- CORRECTED DRAG AND DROP LOGIC ---
function initDashboardDnD() {
    const tableBody = el('#tableDash tbody');
    let draggedRow = null;

    tableBody.addEventListener('dragstart', e => {
        if (!unlocked) return;
        const target = e.target.closest('tr');
        if (!target.draggable) return;
        draggedRow = target;
        isDragging = true;
        setTimeout(() => draggedRow.classList.add('dragging'), 0);
    });

    tableBody.addEventListener('dragend', () => {
        if (draggedRow) draggedRow.classList.remove('dragging');
        draggedRow = null;
        // Set isDragging to false slightly later to avoid race condition with drop
        setTimeout(() => { isDragging = false; }, 100);
    });

    tableBody.addEventListener('dragover', e => {
        e.preventDefault();
        if (!unlocked || !draggedRow) return;
        const afterElement = getDragAfterElement(tableBody, e.clientY);
        tableBody.insertBefore(draggedRow, afterElement);
    });
    
    tableBody.addEventListener('drop', async e => {
        e.preventDefault();
        if (!draggedRow || !unlocked) {
            isDragging = false;
            return;
        }

        const date = el('#d_date').value;
        const orderedIdsOnScreen = [...tableBody.querySelectorAll('tr')].map(row => row.dataset.id);
        const originalJobsForDate = state.jobs
            .filter(j => sameDay(j.date, date))
            .sort((a, b) => a.order_index - b.order_index);

        if (orderedIdsOnScreen.length !== originalJobsForDate.length) {
            console.error("Mismatch between DOM and state. Aborting drop.");
            isDragging = false;
            renderDashboard();
            return;
        }

        const originalIndices = originalJobsForDate.map(j => j.order_index);
        
        const updates = orderedIdsOnScreen.map((jobId, i) => ({
            id: jobId,
            order_index: originalIndices[i]
        }));
        
        const updateMap = new Map(updates.map(u => [u.id, u.order_index]));
        state.jobs.forEach(job => {
            if (updateMap.has(job.id)) {
                job.order_index = updateMap.get(job.id);
            }
        });
        renderDashboard();

        el('#db_status').textContent = 'Saving new order...';
        
        // This is the alternative: multiple updates instead of one upsert
        const promises = updates.map(u => 
            supabaseClient.from('jobs').update({ order_index: u.order_index }).eq('id', u.id)
        );

        const results = await Promise.all(promises);
        const firstError = results.find(res => res.error);

        isDragging = false;

        if (firstError) {
            console.error("Failed to save order", firstError.error);
            alert("ไม่สามารถบันทึกลำดับใหม่ได้");
            el('#db_status').textContent = 'Order save failed!';
            state = await load();
            renderAll();
        } else {
            el('#db_status').textContent = 'Database Synced';
        }
    });

    function getDragAfterElement(container, y) {
        const draggableElements = [...container.querySelectorAll('tr:not(.dragging)')];
        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect(); const offset = y - box.top - box.height / 2;
            return (offset < 0 && offset > closest.offset) ? { offset: offset, element: child } : closest;
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }
}


// --- CALCULATION AND LOGIC FUNCTIONS ---
function calcPlanFor(dept, job){
  const q = job.qty[dept]||0; if(!q) return 0;
  let totalSec = (state.settings.prepPerJob?.[dept]||0) * 60;
  (state.settings.processes[dept]||[]).forEach(p => {
    if (p.type === 'per_piece') {
      totalSec += (p.value || 0) * q;
    } else if (p.type === 'fixed') {
      totalSec += (p.value || 0);
    }
  });
  return totalSec;
}

function procStatus(track){ if(!track?.start && !track?.end) return 'รอดำเนินการ'; if(track?.start && !track?.end) return 'กำลังทำ'; if(track?.end) return 'เสร็จแล้ว'; return 'รอดำเนินการ'; }

function markStart(jobId, dept, proc){
  const job = state.jobs.find(j=>j.id===jobId); if(!job) return;
  const t = job.tracks?.[dept]?.[proc]; if(!t) return;
  if(t.start && !confirm('มีเวลาเริ่มอยู่แล้ว ต้องการแทนที่?')) return;
  t.start = nowISO();
  updateJobField(jobId, { tracks: job.tracks });
  renderDepartments(); renderDashboard();
}
function markEnd(jobId, dept, proc){
  const job = state.jobs.find(j=>j.id===jobId); if(!job) return;
  const t = job.tracks?.[dept]?.[proc]; if(!t) return;
  if(!t.start && !confirm('ยังไม่กดเริ่ม จะบันทึกเสร็จเลยหรือไม่?')) return;
  if(!t.start) t.start = nowISO();
  t.end = nowISO();
  updateJobField(jobId, { tracks: job.tracks });
  renderDepartments(); renderDashboard();
}
function clearTimes(jobId, dept, proc){
  const job = state.jobs.find(j=>j.id===jobId); if(!job) return;
  const t = job.tracks?.[dept]?.[proc]; if(!t) return;
  t.start=null; t.end=null;
  updateJobField(jobId, { tracks: job.tracks });
  renderDepartments(); renderDashboard();
}

function manualSetTime(jobId, dept, proc, type, timeValue) {
    const job = state.jobs.find(j => j.id === jobId);
    if (!job) return;
    const t = job.tracks?.[dept]?.[proc];
    if (!t) return;
    if (!timeValue) {
        t[type] = null;
    } else {
        if (!/^\d{2}:\d{2}$/.test(timeValue)) {
            alert('รูปแบบเวลาไม่ถูกต้อง กรุณใช้ HH:MM');
            renderDepartments(); return;
        }
        const [hours, minutes] = timeValue.split(':').map(Number);
        const date = new Date(job.date);
        date.setHours(hours, minutes, 0, 0);
        t[type] = date.toISOString();
    }
    updateJobField(jobId, { tracks: job.tracks });
    renderDepartments();
    renderDashboard();
}

function completeAllAsPlanned(jobId, dept) {
    if (!confirm('ยืนยันการเสร็จสิ้นทุกขั้นตอนตามเวลาแผน? การกระทำนี้จะเขียนทับเวลาที่บันทึกไว้')) return;
    const job = state.jobs.find(j => j.id === jobId);
    if (!job) return;
    const date = job.date;
    const tl = computePlanTimeline(dept, date, 'cut');
    const jobTimeline = tl.find(t => t.id === jobId);
    if (!jobTimeline) { alert('ไม่สามารถคำนวณแผนสำหรับใบงานนี้ได้'); return; }
    const jobPlanStartSec = jobTimeline.start;
    const procOffsets = calcProcPlanOffsets(dept, job);

    const toISO = (totalSeconds) => {
        const d = new Date(job.date);
        d.setHours(0, 0, 0, 0);
        const roundedSeconds = Math.round(totalSeconds / 60) * 60;
        d.setSeconds(roundedSeconds);
        return d.toISOString();
    };

    procOffsets.forEach(offset => {
        if (!job.tracks[dept]) job.tracks[dept] = {};
        if (!job.tracks[dept][offset.name]) job.tracks[dept][offset.name] = { start: null, end: null };
        job.tracks[dept][offset.name].start = toISO(jobPlanStartSec + offset.startOff);
        job.tracks[dept][offset.name].end = toISO(jobPlanStartSec + offset.endOff);
    });

    updateJobField(jobId, { tracks: job.tracks });
    renderDepartments();
    renderDashboard();
}

function getLatestActualEndSecForDept(job, dept){
  const tmap = job.tracks?.[dept] || {};
  let maxEnd = '';
  Object.values(tmap).forEach(track => { if(track.end && track.end > maxEnd) maxEnd = track.end; });
  return maxEnd ? (new Date(maxEnd).getTime() - new Date(maxEnd).setHours(0,0,0,0)) / 1000 : 0;
}
function getPlannedEndSecForDept(dept, job, date, anchor){
  const tl = computePlanTimeline(dept, date, anchor, { _internalNoPackGate: true });
  const me = tl.find(x=>x.id===job.id);
  return me ? me.end : null;
}

function adjustForBreaks(startSec, durationSec, breakPeriodsSec) {
    let currentStart = startSec;
    let endSec = currentStart + durationSec;
    let adjusted = true;
    while(adjusted) {
        adjusted = false;
        for (const b of breakPeriodsSec) {
            if (currentStart >= b.start && currentStart < b.end) {
                currentStart = b.end; adjusted = true;
            }
        }
    }
    endSec = currentStart + durationSec;
    for (const b of breakPeriodsSec) {
        if (currentStart < b.start && endSec > b.start) {
            endSec += (b.end - b.start);
        }
    }
    return { start: currentStart, end: endSec };
}

function computePlanTimeline(dept, date, anchor = 'cut', opts = {}) {
    const lines = Math.max(1, state.settings.linesPerDept?.[dept] || 1);
    const dayStartSec = parseTimeToMin(state.settings.dayStart) * 60;
    const breakPeriodsSec = (state.settings.deptBreaks[dept] || []).map(b => ({ start: parseTimeToMin(b.start) * 60, end: parseTimeToMin(b.end) * 60 })).sort((a,b) => a.start - b.start);
    const jobsOnDate = state.jobs
        .filter(j => sameDay(j.date, date) && (j.qty[dept] || 0) > 0)
        .sort((a, b) => a.order_index - b.order_index);

    const results = [];
    const lineLastEnd = new Array(lines).fill(dayStartSec);

    jobsOnDate.forEach(j => {
        const li = j.line_assignments[dept] || 0;
        let prevEnd = lineLastEnd[li];
        const prevJobsOnLine = results.filter(r => r.line === li);

        if (prevJobsOnLine.length > 0) {
            const lastJobOnLineResult = prevJobsOnLine[prevJobsOnLine.length - 1];
            const lastJobOnLine = state.jobs.find(jb => jb.id === lastJobOnLineResult.id);
            const actualLastEnd = getLatestActualEndSecForDept(lastJobOnLine, dept);
            prevEnd = actualLastEnd > 0 ? actualLastEnd : lastJobOnLineResult.end;
        }

        const dur = calcPlanFor(dept, j);
        const cutSec = j.cut ? parseTimeToMin(j.cut) * 60 : -Infinity;
        let base = Math.max(prevEnd, cutSec);

        if(dept==='PACK' && !opts._internalNoPackGate){
            let latestOtherEnd = 0;
            state.settings.departments.filter(d => d !== 'PACK' && (j.qty[d]||0) > 0).forEach(od => {
                const actualEnd = getLatestActualEndSecForDept(j, od);
                latestOtherEnd = Math.max(latestOtherEnd, actualEnd > 0 ? actualEnd : (getPlannedEndSecForDept(od, j, date, anchor) || 0));
            });
            base = Math.max(base, latestOtherEnd);
        }
        
        const { start, end } = adjustForBreaks(base, dur, breakPeriodsSec);
        results.push({ id: j.id, start, end, dur, line: li });
        lineLastEnd[li] = end;
    });
    return results;
}

function calcProcPlanOffsets(dept, job){
    const q = job.qty[dept]||0; if(!q) return [];
    let allSteps = [{ name: 'เตรียมไฟล์', duration: (state.settings.prepPerJob?.[dept]||0)*60 }];
    (state.settings.processes[dept]||[]).forEach(p => {
        let duration = 0;
        if (p.type === 'per_piece') {
            duration = (p.value || 0) * q;
        } else if (p.type === 'fixed') {
            duration = (p.value || 0);
        }
        allSteps.push({ name: p.name, duration: duration });
    });
    let offs = []; let cursor = 0;
    allSteps.forEach(p => { offs.push({ name:p.name, startOff:cursor, endOff: cursor + p.duration }); cursor += p.duration; });
    return offs;
}


// --- RENDER FUNCTIONS ---
function renderDepartments(){
  const host = el('#deptBoards'); host.innerHTML='';
  const selDate = el('#dep_date').value || new Date().toISOString().slice(0,10);
  const selDept = el('#dep_filter').value;
  if (!selDept || selDept === 'ALL') { host.innerHTML = '<p class="help">กรุณาเลือกแผนกเพื่อแสดงผล</p>'; return; }
  const dept = selDept;
  const box = cel('div',{class:'card'});
  const inner = cel('div',{class:'inner'});
  const title = cel('div',{ style:'padding:12px 14px;', html:`<div style="display:flex;gap:8px;align-items:center;justify-content:space-between"><div><b>${dept}</b> <span class="muted">(คิวงานตาม Master Plan)</span></div><div class="badge">ขั้นตอน: ${(state.settings.processes[dept]||[]).map(p=>p.name).join(' › ')||'-'}</div></div>`});
  box.append(title, inner);
  const board = cel('div', { class: 'dept-board' });
  inner.appendChild(board);
  const jobsOnDate = state.jobs
    .filter(j=> sameDay(j.date, selDate) && (j.qty[dept]||0)>0 )
    .sort((a,b) => a.order_index - b.order_index);

  const timeline = computePlanTimeline(dept, selDate, 'cut');
  const lines = Math.max(1, state.settings.linesPerDept?.[dept]||1);
  const lineContainers = Array.from({length: lines}, (_, i) => {
      const lineBox = cel('div', { class: 'line-container' });
      const breakTimes = (state.settings.deptBreaks[dept] || []).map(b => `${b.start}-${b.end}`).join(', ');
      lineBox.innerHTML = `<h3>Line ${i + 1} <small>(พัก: ${breakTimes || 'ไม่มี'})</small></h3>`;
      const list = cel('div', { class: 'list' });
      lineBox.appendChild(list);
      board.appendChild(lineBox);
      return list;
  });
  jobsOnDate.forEach(j=>{
      const jtl = timeline.find(x=>x.id===j.id);
      const lineIndex = j.line_assignments[dept] || 0;
      const planSec = calcPlanFor(dept,j);
      const startLabel = jtl ? secToHHMM(jtl.start) : '-';
      const endLabel = jtl ? secToHHMM(jtl.end) : '-';
      const jobCard = cel('div',{class:'job', 'data-id': j.id});
      jobCard.innerHTML = `<div class="jobhead"><div style="flex:1"><div class="title">${j.name}</div><small><b>Cut:</b> ${j.cut||'-'} &nbsp;&nbsp;•&nbsp;&nbsp; <b>Line:</b> ${lineIndex + 1}</small></div><button class="btn mini gray toggle">รายละเอียด</button></div><div style="padding-top:8px;"><div><b>Plan: ${startLabel}-${endLabel}</b> (${Math.round(planSec/60)} min) <b>Qty:</b> ${j.qty[dept]}</div><div class="job-status-container" style="display: flex; align-items: center; gap: 6px; margin-top: 4px;"><span>สถานะ:</span> <span class="status-badge">รอดำเนินการ</span></div><div style="display:flex; gap:6px; margin-top:8px;"><button class="btn mini gray btn-complete-plan">เสร็จสิ้นตาม Plan</button></div></div>`;
      const procWrap = cel('div',{class: 'procwrap hidden' });
      const procOffsets = calcProcPlanOffsets(dept, j);
      
      procOffsets.forEach(offset => {
          const procName = offset.name;
          const process = (procName === 'เตรียมไฟล์') 
              ? { name: 'เตรียมไฟล์', type: 'per_piece' }
              : (state.settings.processes[dept] || []).find(p => p.name === procName);

          if (!process) return;

          const trackObj = j.tracks?.[dept]?.[procName] || {start:null, end:null};
          const block = cel('div',{class:'proc'});
          const startPH = jtl ? secToHHMM(jtl.start + offset.startOff) : '';
          const endPH = jtl ? secToHHMM(jtl.start + offset.endOff) : '';
          const startValue = trackObj.start ? fmtLocalHHMM(trackObj.start) : '';
          const endValue = trackObj.end ? fmtLocalHHMM(trackObj.end) : '';

          block.innerHTML = `<h4>${procName} ${process.type === 'fixed' ? '<span class="plan-time-hint">(เวลาคงที่)</span>' : ''}</h4>
            <div class="grid2">
                <div class="timebox">
                    <span class="muted">เริ่ม <span class="plan-time-hint">(${startPH || '--:--'})</span></span>
                    <input type="time" class="manual-time-input" data-j="${j.id}" data-d="${dept}" data-p="${procName}" data-type="start" value="${startValue}">
                </div>
                <div class="timebox">
                    <span class="muted">เสร็จ <span class="plan-time-hint">(${endPH || '--:--'})</span></span>
                    <input type="time" class="manual-time-input" data-j="${j.id}" data-d="${dept}" data-p="${procName}" data-type="end" value="${endValue}">
                </div>
            </div>
            <div class="act">
                <button class="btn mini" data-act="start" data-j="${j.id}" data-d="${dept}" data-p="${procName}">เริ่ม</button>
                <button class="btn mini secondary" data-act="end" data-j="${j.id}" data-d="${dept}" data-p="${procName}">เสร็จ</button>
                <button class="btn mini gray" data-act="clear" data-j="${j.id}" data-d="${dept}" data-p="${procName}">ล้าง</button>
                <span class="badge">สถานะ: ${procStatus(trackObj)}</span>
            </div>`;
          procWrap.appendChild(block);
      });

      jobCard.appendChild(procWrap);
      if(isExpanded(dept, j.id)) procWrap.classList.remove('hidden');
      jobCard.querySelector('.toggle').onclick = ()=>{ procWrap.classList.toggle('hidden'); setExpanded(dept, j.id, !procWrap.classList.contains('hidden')); };
      jobCard.querySelector('.btn-complete-plan').onclick = () => completeAllAsPlanned(j.id, dept);
      const statusInfo = getJobStatusForDept(j, dept);
      if (statusInfo.key !== 'pending') jobCard.classList.add('job-card-' + statusInfo.key);
      const statusBadge = jobCard.querySelector('.status-badge');
      statusBadge.textContent = statusInfo.text;
      statusBadge.className = 'status-badge';
      if (statusInfo.key !== 'pending') statusBadge.classList.add('status-' + statusInfo.key);
      if (lineContainers[lineIndex]) lineContainers[lineIndex].appendChild(jobCard);
  });
  host.appendChild(box);
  host.querySelectorAll('button[data-act]').forEach(b=>{
    b.addEventListener('click', ()=>{
      const { j, d, p, act } = b.dataset;
      if(act==='start') markStart(j,d,p); if(act==='end') markEnd(j,d,p); if(act==='clear') clearTimes(j,d,p);
    });
  });
  host.querySelectorAll('.manual-time-input').forEach(input => {
      input.addEventListener('change', (e) => {
          const { j, d, p, type } = e.target.dataset;
          manualSetTime(j, d, p, type, e.target.value);
      });
  });
}

function renderDashboard(){
  el('#d_date').disabled = !unlocked;
  const date = el('#d_date').value || new Date().toISOString().slice(0,10);
  const thead = el('#tableDash thead'); const tbody = el('#tableDash tbody');
  let headerHTML = '<tr><th style="width:20px;"></th><th style="min-width:160px">ใบงาน</th><th class="cut-time-divider">เวลาตัด</th>';
  state.settings.departments.forEach(d => {
      headerHTML += `<th class="dept-divider">${d}: สถานะ / ไลน์</th><th>${d}: แผนเริ่ม</th><th>${d}: แผนเสร็จ</th>`;
  });
  headerHTML += '</tr>';
  thead.innerHTML = headerHTML;
  tbody.innerHTML = '';
  const dayJobs = state.jobs.filter(j=> sameDay(j.date,date)).sort((a, b) => a.order_index - b.order_index);
  el('#kpiBar').innerHTML = state.settings.departments.map(d => {
      const tl = computePlanTimeline(d, date, 'cut');
      const totalSec = tl.reduce((sum, item) => sum + item.dur, 0);
      const finishSec = tl.length? Math.max(...tl.map(x=>x.end)) : 0;
      const ot = Math.max(0, Math.round(finishSec/60) - parseTimeToMin(state.settings.dayEnd));
      return `<span class="pill"><b>${d}</b> • ${state.settings.linesPerDept?.[d]||1} ไลน์ • รวม ${fmtTime(totalSec)} • เสร็จ ~ ${secToHHMM(finishSec)} ${ot? `(OT ~ ${Math.floor(ot)} นาที)`:''}</span>`;
  }).join('');
  const timelines = {};
  state.settings.departments.forEach(d => { timelines[d] = computePlanTimeline(d, date, 'cut'); });
  dayJobs.forEach(j=>{
    const tr = cel('tr', { 'data-id': j.id });
    tr.draggable = unlocked;
    tr.innerHTML = `<td class="drag-handle">${unlocked ? '☰' : ''}</td><td>${j.name}</td><td class="cut-time-divider">${j.cut || '-'}</td>`;
    state.settings.departments.forEach(d=>{
      const tdStatus = cel('td', {class:'dept-divider'});
      const tdStart = cel('td');
      const tdEnd = cel('td');
      if((j.qty[d]||0)>0){
        const statusInfo = getJobStatusForDept(j, d);
        const me = timelines[d].find(x=>x.id===j.id);
        tdStart.textContent = me ? secToHHMM(me.start) : '-';
        tdEnd.textContent = me ? secToHHMM(me.end) : '-';
        tdStatus.innerHTML = `<div class="status-cell"><span>${statusInfo.text}</span></div>`;
        const lineSelect = cel('select', { class: 'line-assign-select', 'data-job-id': j.id, 'data-dept': d });
        lineSelect.disabled = !unlocked;
        const lines = state.settings.linesPerDept[d] || 1;
        for (let i = 0; i < lines; i++) {
            const opt = cel('option', { value: i, text: `Line ${i + 1}`});
            if ((j.line_assignments[d] || 0) === i) opt.selected = true;
            lineSelect.appendChild(opt);
        }
        lineSelect.onchange = (e) => {
            const { jobId, dept } = e.target.dataset;
            const line = parseInt(e.target.value);
            const jobToUpdate = state.jobs.find(jb => jb.id === jobId);
            if(jobToUpdate) {
                jobToUpdate.line_assignments[dept] = line;
                updateJobField(jobId, { line_assignments: jobToUpdate.line_assignments });
                renderAll();
            }
        };
        tdStatus.querySelector('.status-cell').appendChild(lineSelect);
      } else {
        tdStart.textContent = '-'; tdEnd.textContent = '-'; tdStatus.innerHTML = '-';
      }
      tr.append(tdStatus, tdStart, tdEnd);
    });
    const overallStatus = getOverallJobStatus(j);
    if (overallStatus.key !== 'pending') tr.classList.add('status-row-' + overallStatus.key);
    tbody.appendChild(tr);
  });
  initDashboardDnD();
}

el('#btnUnlock').onclick=()=>{
  const p = el('#pass').value;
  if (p !== LOCK_PASS) {
    alert('รหัสผ่านไม่ถูกต้อง');
    return;
  }
  unlocked = !unlocked;
  el('#lockState').textContent = unlocked ? 'เปิด' : 'ปิด';
  el('#btnClearAll').disabled = !unlocked;
  if (!unlocked) el('#pass').value = '';
  renderAll();
};

function migrateSettingsForProcessTypes(settings) {
    let migrationNeeded = false;
    Object.values(settings.processes).forEach(procList => {
        if (procList.length > 0 && procList[0].secPerPiece !== undefined) {
            migrationNeeded = true;
        }
    });

    if (!migrationNeeded && settings.waitFixedPerJob === undefined) return;

    console.log("Migrating settings to new process structure...");
    
    settings.departments.forEach(d => {
        if (settings.processes[d]) {
            settings.processes[d].forEach(p => {
                if (p.secPerPiece !== undefined) {
                    p.value = p.secPerPiece;
                    p.type = 'per_piece';
                    delete p.secPerPiece;
                }
            });
        }
        if (settings.waitFixedPerJob && settings.waitFixedPerJob[d] > 0) {
            if (!settings.processes[d]) settings.processes[d] = [];
            settings.processes[d].push({
                name: 'Wait Time (เก่า)',
                type: 'fixed',
                value: settings.waitFixedPerJob[d] * 60
            });
        }
    });
    
    delete settings.waitFixedPerJob;
    console.log("Migration complete.");
}

function ensureDeptBaseline(s=state){
  s.settings.departments.forEach(d=>{
      s.settings.processes[d]=s.settings.processes[d]||[];
      if(s.settings.prepPerJob[d]==null) s.settings.prepPerJob[d]=10;
      s.settings.deptBreaks[d]=s.settings.deptBreaks[d]||[];
      if(s.settings.linesPerDept[d]==null) s.settings.linesPerDept[d]=1;
  });
  s.jobs.forEach(j=>{
    if (j.order_index == null) j.order_index = 0;
    j.line_assignments = j.line_assignments || {};
    s.settings.departments.forEach(d=>{ if(!(d in (j.qty||{}))) j.qty[d]=0; });
  });
}

function migrateDeptRename(oldName,newName){
  if(oldName===newName) return;
  const idx = state.settings.departments.indexOf(oldName); if(idx>-1) state.settings.departments[idx]=newName;
  ['processes','prepPerJob','deptBreaks','linesPerDept'].forEach(key => {
    if(state.settings[key][oldName] != null){ state.settings[key][newName] = state.settings[key][oldName]; delete state.settings[key][oldName]; }
  });
  state.jobs.forEach(j=>{
    if(j.qty[oldName]!=null){ j.qty[newName]=j.qty[oldName]; delete j.qty[oldName]; }
    if(j.tracks?.[oldName]){ j.tracks[newName]=j.tracks[oldName]; delete j.tracks[oldName]; }
    if(j.line_assignments?.[oldName]){ j.line_assignments[newName]=j.line_assignments[oldName]; delete j.line_assignments[oldName]; }
  });
}

function renderDeptManager(){
  const host=el('#deptManager'); host.innerHTML='';
  state.settings.departments.forEach((d,i)=>{
    const row=cel('div',{style:'display:flex;gap:6px;align-items:center;margin-bottom:4px;'});
    const nameInp=cel('input',{value:d, style:'flex:1;'}); nameInp.disabled=!unlocked;
    nameInp.onchange= async ()=>{ const nv=nameInp.value.trim()||d; migrateDeptRename(d,nv); await saveSettings(state.settings); renderAll(); };
    const up=cel('button',{class:'btn mini gray',text:'↑'}); const dn=cel('button',{class:'btn mini gray',text:'↓'}); const del=cel('button',{class:'btn mini danger',text:'ลบ'});
    [up,dn,del].forEach(b=> b.disabled=!unlocked);
    up.onclick= async ()=>{ if(i>0){ [state.settings.departments[i-1], state.settings.departments[i]] = [state.settings.departments[i], state.settings.departments[i-1]]; await saveSettings(state.settings); renderAll(); }}
    dn.onclick= async ()=>{ if(i<state.settings.departments.length-1){ [state.settings.departments[i+1], state.settings.departments[i]] = [state.settings.departments[i], state.settings.departments[i+1]]; await saveSettings(state.settings); renderAll(); }}
    del.onclick= async ()=>{ if(!confirm(`ลบแผนก ${d}?`)) return; state.settings.departments.splice(i,1); await saveSettings(state.settings); renderAll(); };
    row.append(nameInp,up,dn,del);
    host.appendChild(row);
  });
}
el('#btnAddDept').onclick= async ()=>{ if(!unlocked) return alert('ปลดล็อกก่อน'); const name=prompt('ชื่อแผนกใหม่'); if(!name) return; state.settings.departments.push(name.trim()); ensureDeptBaseline(); await saveSettings(state.settings); renderAll(); };

function renderProcessPane(){
  const sel = el('#deptSel'); sel.innerHTML='';
  state.settings.departments.forEach(d=>{ const o=cel('option',{value:d,text:d}); sel.appendChild(o); });
  if(currentDeptSel && state.settings.departments.includes(currentDeptSel)) sel.value=currentDeptSel; else {currentDeptSel=state.settings.departments[0]||null; if(currentDeptSel) sel.value=currentDeptSel;}
  sel.onchange=()=>{ currentDeptSel = sel.value; drawEditorsForDept(); };
  drawEditorsForDept();
}

function drawEditorsForDept() { if (!currentDeptSel) return; drawProcList(); drawPrepAndWaitEditor(); drawLinesAndBreaksEditor(); }

function drawProcList(){
  const d = currentDeptSel; const procEd = el('#procEditor'); procEd.innerHTML='';
  const arr = state.settings.processes[d]||[];
  arr.forEach((p,i)=>{
    const row=cel('div',{style:'display:grid;grid-template-columns:1fr 140px 140px auto; gap:6px;align-items:center;margin-bottom:6px;'});
    
    const nameInp=cel('input',{value:p.name, placeholder: 'ชื่อขั้นตอน'}); nameInp.disabled=!unlocked;
    nameInp.onchange= async ()=>{ p.name = nameInp.value.trim(); await saveSettings(state.settings); drawEditorsForDept(); };
    
    const typeSel = cel('select');
    typeSel.innerHTML = `<option value="per_piece">ต่อชิ้น</option><option value="fixed">คงที่</option>`;
    typeSel.value = p.type || 'per_piece';
    typeSel.disabled=!unlocked;
    
    const valueInp=cel('input',{type:'number', value: p.type === 'fixed' ? (p.value/60) : p.value, step:'1', min:'0'});
    valueInp.disabled=!unlocked;

    const unitLabel = cel('label', { text: p.type === 'fixed' ? 'นาที (คงที่)' : 'วินาที/ชิ้น' });

    typeSel.onchange = async () => {
        p.type = typeSel.value;
        valueInp.value = 0;
        p.value = 0;
        await saveSettings(state.settings);
        drawEditorsForDept();
    };

    valueInp.onchange= async ()=>{ 
        p.value = p.type === 'fixed' ? (parseFloat(valueInp.value) * 60) : (parseInt(valueInp.value) || 0);
        await saveSettings(state.settings); 
        renderDashboard(); 
    };

    const ctrl=cel('div',{class:'inline'});
    const up=cel('button',{class:'btn mini gray',text:'↑'}); const dn=cel('button',{class:'btn mini gray',text:'↓'}); const del=cel('button',{class:'btn mini danger',text:'ลบ'});
    [up,dn,del].forEach(b=> b.disabled=!unlocked);
    up.onclick= async ()=>{ if(i>0){ [arr[i-1], arr[i]] = [arr[i], arr[i-1]]; await saveSettings(state.settings); drawEditorsForDept(); } };
    dn.onclick= async ()=>{ if(i<arr.length-1){ [arr[i+1], arr[i]] = [arr[i], arr[i+1]]; await saveSettings(state.settings); drawEditorsForDept(); } };
    del.onclick= async ()=>{ if(!confirm(`ลบขั้นตอน ${p.name}?`)) return; arr.splice(i,1); await saveSettings(state.settings); drawEditorsForDept(); };
    ctrl.append(up,dn,del); 
    
    const valueWrap = cel('div');
    valueWrap.append(valueInp, unitLabel);
    
    row.append(nameInp, typeSel, valueWrap, ctrl); 
    procEd.appendChild(row);
  });
}

el('#btnAddProc').onclick= async ()=>{ 
    if(!unlocked) return alert('ปลดล็อกก่อน'); 
    const d=currentDeptSel; 
    const name=prompt('ชื่อขั้นตอนใหม่'); 
    if(!name) return; 
    (state.settings.processes[d]=state.settings.processes[d]||[]).push({name:name.trim(), type:'per_piece', value:0}); 
    await saveSettings(state.settings); 
    drawEditorsForDept(); 
};

function drawPrepAndWaitEditor() {
    const d = currentDeptSel;
    el('#prepEditor').innerHTML = '';
    const prepInp=cel('input',{type:'number', step:'1', min:'0', value: state.settings.prepPerJob?.[d]||10});
    prepInp.disabled=!unlocked; prepInp.onchange= async ()=>{ state.settings.prepPerJob[d] = parseFloat(prepInp.value)||10; await saveSettings(state.settings); renderDashboard(); };
    el('#prepEditor').appendChild(prepInp);
}

function drawLinesAndBreaksEditor() {
    const d = currentDeptSel;
    el('#linesEditor').innerHTML = '';
    const linesInp=cel('input',{type:'number', step:'1', min:'1', value: state.settings.linesPerDept?.[d]||1});
    linesInp.disabled=!unlocked; linesInp.onchange= async ()=>{ state.settings.linesPerDept[d] = parseInt(linesInp.value)||1; await saveSettings(state.settings); renderDashboard(); };
    el('#linesEditor').appendChild(linesInp);
    const breaksHost = el('#breaksEditor'); breaksHost.innerHTML = '';
    const breaks = state.settings.deptBreaks[d] || [];
    breaks.forEach((breakItem, i) => {
        const row = cel('div', { class:'inline', style:'margin-bottom:4px;width:100%;gap:4px;'});
        const startInp = cel('input', {type:'time', value: breakItem.start});
        const endInp = cel('input', {type:'time', value: breakItem.end});
        const delBtn = cel('button', {class:'btn mini danger', text:'ลบ'});
        [startInp, endInp, delBtn].forEach(el => el.disabled = !unlocked);
        startInp.onchange = async () => { breakItem.start = startInp.value; await saveSettings(state.settings); renderDashboard(); };
        endInp.onchange = async () => { breakItem.end = endInp.value; await saveSettings(state.settings); renderDashboard(); };
        delBtn.onclick = async () => { breaks.splice(i, 1); await saveSettings(state.settings); drawLinesAndBreaksEditor(); renderDashboard(); };
        row.append(startInp, endInp, delBtn);
        breaksHost.appendChild(row);
    });
}
el('#btnAddBreak').onclick = async () => {
    if(!unlocked) return alert('ปลดล็อกก่อน');
    const d = currentDeptSel;
    if(!state.settings.deptBreaks[d]) state.settings.deptBreaks[d] = [];
    state.settings.deptBreaks[d].push({start: '12:00', end: '13:00'});
    await saveSettings(state.settings);
    drawLinesAndBreaksEditor();
};

function getOverallJobStatus(job) {
    const relevantDepts = state.settings.departments.filter(d => (job.qty[d] || 0) > 0);
    if (relevantDepts.length === 0) return { key: 'pending' };
    const statuses = relevantDepts.map(d => getJobStatusForDept(job, d).key);
    if (statuses.every(s => s === 'done')) return { key: 'done' };
    if (statuses.some(s => s === 'progress')) return { key: 'progress' };
    return { key: 'pending' };
}

function getJobStatusForDept(job, dept) {
    const procs = ['เตรียมไฟล์', ...(state.settings.processes[dept] || []).map(p => p.name)];
    const tracks = job.tracks[dept] || {};
    const totalSteps = procs.length;
    const completedSteps = procs.filter(p => tracks[p]?.end).length;

    if (totalSteps > 0 && completedSteps === totalSteps) {
        const lastFinishedTime = Object.values(tracks).reduce((latest, t) => t.end > latest ? t.end : latest, '');
        return { text: `เสร็จแล้ว @ ${fmtLocalHHMM(lastFinishedTime)}`, key: 'done' };
    }
    if (Object.values(tracks).some(t => t.start)) {
        const currentStep = procs.find(p => tracks[p]?.start && !tracks[p]?.end) || procs.find(p => !tracks[p]?.end);
        return { text: `กำลังทำ: ${currentStep}`, key: 'progress' };
    }
    return { text: 'รอดำเนินการ', key: 'pending' };
}

el('#btnNewJob').onclick = ()=>{ show('form'); };
el('#btnDepartments').onclick = ()=>{ show('dept'); renderDepartments(); };
el('#btnDashboard').onclick = ()=>{ show('dash'); renderDashboard(); };
el('#btnSettings').onclick = ()=>{ show('set'); renderSettings(); };
el('#btnJobs').onclick = ()=>{ show('jobs'); renderJobs(); };
el('#btnAddJob').onclick = addJob; el('#btnClearForm').onclick = clearForm; el('#btnSaveJob').onclick = saveJobEdit; el('#btnCancelEdit').onclick = ()=>{ clearForm(); show('jobs'); };
el('#j_date').onchange = renderJobs; el('#j_search').oninput = renderJobs;
el('#j_clear').onclick=()=>{ el('#j_date').value=''; el('#j_search').value=''; renderJobs(); };
el('#dep_date').onchange = renderDepartments; el('#dep_filter').onchange = renderDepartments;
el('#d_date').onchange = renderDashboard;

el('#btnClearAll').onclick = async ()=>{
    if(!unlocked) return alert('ต้องปลดล็อกก่อน');
    if(confirm('คำเตือน!! การกระทำนี้จะลบข้อมูลใบงานและการตั้งค่าทั้งหมดออกจากฐานข้อมูลอย่างถาวร ยืนยันที่จะดำเนินการต่อ?')){
        el('#db_status').textContent = 'DELETING ALL DATA...';
        const { error: jobsError } = await supabaseClient.from('jobs').delete().neq('id', 'a-dummy-id-that-does-not-exist');
        const { error: settingsError } = await supabaseClient.from('settings').delete().eq('id', 1);
        if(jobsError || settingsError) {
            alert('เกิดข้อผิดพลาดในการล้างข้อมูล!');
            console.error('Jobs Error:', jobsError); console.error('Settings Error:', settingsError);
            el('#db_status').textContent = 'Error Deleting Data!';
        } else {
            alert('ล้างข้อมูลทั้งหมดสำเร็จแล้ว!'); window.location.reload();
        }
    }
}

function renderSettings(){
  renderDeptManager();
  renderProcessPane();
  el('#s_dayStart').value = state.settings.dayStart;
  el('#s_dayEnd').value = state.settings.dayEnd;
  el('#s_dayStart').onchange = async () => { state.settings.dayStart = el('#s_dayStart').value; await saveSettings(state.settings); renderDashboard(); };
  el('#s_dayEnd').onchange = async () => { state.settings.dayEnd = el('#s_dayEnd').value; await saveSettings(state.settings); renderDashboard(); };
  [...document.querySelectorAll('#viewSettings input, #viewSettings select, #viewSettings button')].forEach(elem => {
      if(!elem.closest('.right')) elem.disabled = !unlocked;
  });
}

function populateJobDateFilter() {
    const dateSelect = el('#j_date');
    const currentValue = dateSelect.value;
    dateSelect.innerHTML = '';
    const uniqueDates = [...new Set(state.jobs.map(job => job.date))].sort((a, b) => b.localeCompare(a));
    dateSelect.add(new Option('-- ทุกวัน --', ''));
    uniqueDates.forEach(date => dateSelect.add(new Option(date, date)));
    dateSelect.value = currentValue;
}

function refreshDepFilter(){
    const sel = el('#dep_filter');
    const currentVal = sel.value;
    sel.innerHTML='';
    sel.appendChild(cel('option',{value:'ALL',text:'-- เลือกแผนก --'}));
    state.settings.departments.forEach(d=> sel.appendChild(cel('option',{value:d,text:d})));
    sel.value = currentVal;
    if (sel.selectedIndex < 1 && currentVal !== 'ALL') sel.value = 'ALL';
}

function renderAll(){
  const keepSel = el('#deptSel')?.value || currentDeptSel;
  ensureDeptBaseline();
  renderQtyGrid();
  refreshDepFilter();
  populateJobDateFilter();
  const currentHandlers = { dash: renderDashboard, dept: renderDepartments, jobs: renderJobs, set: renderSettings, form: () => show('form') };
  if(currentHandlers[currentView]) currentHandlers[currentView]();
  if (currentView === 'set') {
    currentDeptSel = keepSel;
    const sel = el('#deptSel');
    if (sel && currentDeptSel && [...sel.options].some(o=>o.value===currentDeptSel)) sel.value = currentDeptSel;
  }
  setActive(currentView);
}

// --- IMPORT / EXPORT FUNCTIONS ---
function exportSettingsXLSX() {
    if (!unlocked) { alert('กรุณาปลดล็อกระบบก่อนทำการ Export Settings.'); return; }
    const settings = JSON.parse(JSON.stringify(state.settings));
    const wb = XLSX.utils.book_new();
    const ws1_data = [["Setting", "Value"],["Day Start", settings.dayStart],["Day End", settings.dayEnd]];
    const ws1 = XLSX.utils.aoa_to_sheet(ws1_data);
    XLSX.utils.book_append_sheet(wb, ws1, "General Settings");
    const ws2_data = [["Order", "Department Name"]];
    settings.departments.forEach((d, i) => { ws2_data.push([i + 1, d]); });
    const ws2 = XLSX.utils.aoa_to_sheet(ws2_data);
    XLSX.utils.book_append_sheet(wb, ws2, "Departments");
    const ws3_data = [["Department", "Process Name", "Process Type", "Value", "Unit"]];
    settings.departments.forEach(d => {
        if (settings.processes[d]) {
            settings.processes[d].forEach(p => {
                const isFixed = p.type === 'fixed';
                const value = isFixed ? (p.value / 60) : p.value;
                const unit = isFixed ? 'minutes' : 'seconds/piece';
                ws3_data.push([d, p.name, p.type, value, unit]);
            });
        }
    });
    const ws3 = XLSX.utils.aoa_to_sheet(ws3_data);
    XLSX.utils.book_append_sheet(wb, ws3, "Processes");
    const ws4_data = [["Department", "Prep Time (minutes)"]];
    settings.departments.forEach(d => { ws4_data.push([d, settings.prepPerJob[d] || 0]); });
    const ws4 = XLSX.utils.aoa_to_sheet(ws4_data);
    XLSX.utils.book_append_sheet(wb, ws4, "Prep Time");
    const ws5_data = [["Department", "Break Start", "Break End"]];
    settings.departments.forEach(d => {
        if (settings.deptBreaks[d]) {
            settings.deptBreaks[d].forEach(b => { ws5_data.push([d, b.start, b.end]); });
        }
    });
    const ws5 = XLSX.utils.aoa_to_sheet(ws5_data);
    XLSX.utils.book_append_sheet(wb, ws5, "Department Breaks");
    const ws6_data = [["Department", "Number of Production Lines"]];
    settings.departments.forEach(d => { ws6_data.push([d, settings.linesPerDept[d] || 1]); });
    const ws6 = XLSX.utils.aoa_to_sheet(ws6_data);
    XLSX.utils.book_append_sheet(wb, ws6, "Production Lines");
    XLSX.writeFile(wb, `Production_Settings_${new Date().toISOString().slice(0, 10)}.xlsx`);
}

async function importSettingsXLSX(file) {
    if (!unlocked) { alert('กรุณาปลดล็อกระบบก่อนทำการ Import Settings.'); return; }
    const reader = new FileReader();
    reader.onload = async (event) => {
        try {
            const data = new Uint8Array(event.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            let newSettings = JSON.parse(JSON.stringify(defaultModel().settings));
            if (workbook.SheetNames.includes("General Settings")) {
                const ws = workbook.Sheets["General Settings"];
                const json = XLSX.utils.sheet_to_json(ws, { header: 1 });
                json.forEach(row => {
                    if (row[0] === "Day Start") newSettings.dayStart = row[1];
                    if (row[0] === "Day End") newSettings.dayEnd = row[1];
                });
            }
            if (workbook.SheetNames.includes("Departments")) {
                const ws = workbook.Sheets["Departments"];
                const json = XLSX.utils.sheet_to_json(ws);
                newSettings.departments = json.sort((a, b) => a.Order - b.Order).map(row => row["Department Name"]).filter(Boolean);
            }
            newSettings.processes = {};
            if (workbook.SheetNames.includes("Processes")) {
                const ws = workbook.Sheets["Processes"];
                const json = XLSX.utils.sheet_to_json(ws);
                json.forEach(row => {
                    const deptName = row["Department"];
                    if (deptName && newSettings.departments.includes(deptName)) {
                        if (!newSettings.processes[deptName]) newSettings.processes[deptName] = [];
                        const isFixed = row["Process Type"] === 'fixed';
                        const value = Number(row["Value"]) || 0;
                        newSettings.processes[deptName].push({ name: row["Process Name"], type: row["Process Type"] || 'per_piece', value: isFixed ? (value * 60) : value });
                    }
                });
            }
            newSettings.prepPerJob = {};
            if (workbook.SheetNames.includes("Prep Time")) {
                const ws = workbook.Sheets["Prep Time"];
                const json = XLSX.utils.sheet_to_json(ws);
                json.forEach(row => {
                    const deptName = row["Department"];
                    if (deptName && newSettings.departments.includes(deptName)) newSettings.prepPerJob[deptName] = Number(row["Prep Time (minutes)"]) || 0;
                });
            }
            newSettings.deptBreaks = {};
            if (workbook.SheetNames.includes("Department Breaks")) {
                const ws = workbook.Sheets["Department Breaks"];
                const json = XLSX.utils.sheet_to_json(ws);
                json.forEach(row => {
                    const deptName = row["Department"];
                    if (deptName && newSettings.departments.includes(deptName)) {
                        if (!newSettings.deptBreaks[deptName]) newSettings.deptBreaks[deptName] = [];
                        newSettings.deptBreaks[deptName].push({ start: row["Break Start"], end: row["Break End"] });
                    }
                });
            }
            newSettings.linesPerDept = {};
            if (workbook.SheetNames.includes("Production Lines")) {
                const ws = workbook.Sheets["Production Lines"];
                const json = XLSX.utils.sheet_to_json(ws);
                json.forEach(row => {
                    const deptName = row["Department"];
                    if (deptName && newSettings.departments.includes(deptName)) newSettings.linesPerDept[deptName] = Number(row["Number of Production Lines"]) || 1;
                });
            }
            await saveSettings(newSettings);
            state.settings = newSettings;
            alert('นำเข้าการตั้งค่าสำเร็จแล้ว!');
            renderAll();
        } catch (err) {
            alert(`เกิดข้อผิดพลาดในการนำเข้าไฟล์การตั้งค่า: ${err.message}`);
        } finally {
            el('#fileImportSettingsXLSX').value = '';
        }
    };
    reader.readAsArrayBuffer(file);
}

el('#btnExportSettingsXLSX').onclick = exportSettingsXLSX;
el('#fileImportSettingsXLSX').addEventListener('change', (e) => {
    if (e.target.files[0]) importSettingsXLSX(e.target.files[0]);
});

function getActualTimesForDept(job, dept) {
    const tracks = job.tracks?.[dept] || {};
    const procNames = ['เตรียมไฟล์', ...(state.settings.processes[dept] || []).map(p => p.name)];
    let firstStart = null;
    let lastEnd = null;
    for (const procName of procNames) {
        const track = tracks[procName];
        if (track?.start) {
            const currentStart = new Date(track.start);
            if (!firstStart || currentStart < firstStart) firstStart = currentStart;
        }
        if (track?.end) {
            const currentEnd = new Date(track.end);
            if (!lastEnd || currentEnd > lastEnd) lastEnd = currentEnd;
        }
    }
    return {
        actualStart: firstStart ? fmtLocalHHMM(firstStart.toISOString()) : '-',
        actualEnd: lastEnd ? fmtLocalHHMM(lastEnd.toISOString()) : '-'
    };
}

el('#btnDownloadXLSX').onclick = () => {
    if (!unlocked) { alert('กรุณาปลดล็อกระบบก่อนทำการ Download Excel.'); return; }
    const date = el('#d_date').value || new Date().toISOString().slice(0, 10);
    const dayJobs = state.jobs.filter(j => sameDay(j.date, date)).sort((a,b) => a.order_index - b.order_index);
    const wb = XLSX.utils.book_new();
    const timelines = {};
    state.settings.departments.forEach(d => { timelines[d] = computePlanTimeline(d, date, 'cut'); });
    state.settings.departments.forEach(dept => {
        const deptHeader = ['ลำดับ', 'ชื่อใบงาน', 'เวลาตัด', 'จำนวน', 'ไลน์', 'สถานะ', 'แผนเริ่ม', 'แผนเสร็จ', 'เริ่มจริง', 'เสร็จจริง'];
        const deptData = [deptHeader];
        const deptJobs = dayJobs.filter(j => (j.qty[dept] || 0) > 0);
        deptJobs.forEach((job, index) => {
            const statusInfo = getJobStatusForDept(job, dept);
            const me = timelines[dept].find(x => x.id === job.id);
            const { actualStart, actualEnd } = getActualTimesForDept(job, dept);
            const assignedLine = (job.line_assignments[dept] || 0) + 1;
            const row = [index + 1, job.name, job.cut || '-', job.qty[dept], `Line ${assignedLine}`, statusInfo.text, me ? secToHHMM(me.start) : '-', me ? secToHHMM(me.end) : '-', actualStart, actualEnd];
            deptData.push(row);
        });
        const ws = XLSX.utils.aoa_to_sheet(deptData);
        ws['!cols'] = [{ wch: 5 },{ wch: 25 },{ wch: 10 },{ wch: 8 },{ wch: 8 },{ wch: 20 },{ wch: 10 },{ wch: 10 },{ wch: 10 },{ wch: 10 }];
        XLSX.utils.book_append_sheet(wb, ws, dept);
    });
    XLSX.writeFile(wb, `Master_Plan_By_Dept_${date}.xlsx`);
};

el('#btnDownloadTemplateXLSX').onclick = () => {
    if (!unlocked) { alert('กรุณาปลดล็อกระบบก่อนทำการ Download Template.'); return; }
    const templateHeader = ['date', 'name', 'cut', ...state.settings.departments];
    const exampleRow = [new Date().toISOString().slice(0, 10), 'ตัวอย่าง-ชื่องาน-01', '09:30', ...state.settings.departments.map((d, i) => i === 0 ? 100 : 0)];
    const data = [templateHeader, exampleRow];
    const ws = XLSX.utils.aoa_to_sheet(data);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, "Jobs Template");
    XLSX.writeFile(wb, `Jobs_Import_Template.xlsx`);
};

async function importJobsXLSX(file) {
    if (!unlocked) { alert('กรุณาปลดล็อกก่อน'); return; }
    const reader = new FileReader();
    reader.onload = async (event) => {
        let successCount = 0; let failCount = 0; let failedRows = [];
        try {
            const data = new Uint8Array(event.target.result);
            const workbook = XLSX.read(data, { type: 'array', cellDates:true });
            const sheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[sheetName];
            const json = XLSX.utils.sheet_to_json(worksheet, {raw: false});
            if (!json.length) throw new Error("ไฟล์ Excel ว่างเปล่า");
            const newJobs = [];
            const maxOrderIndex = state.jobs.length > 0 ? Math.max(...state.jobs.map(j => j.order_index)) : -1;
            json.forEach((row, index) => {
                if (!row.name || !row.date) { failCount++; failedRows.push(index + 2); return; }
                const qty = {};
                state.settings.departments.forEach(d => { qty[d] = Number(row[d]) || 0; });
                const jobDate = new Date(row.date);
                jobDate.setMinutes(jobDate.getMinutes() - jobDate.getTimezoneOffset());
                const job = createJobObject({
                    date: jobDate.toISOString().slice(0, 10),
                    name: String(row.name), cut: String(row.cut || ''), qty: qty
                });
                job.order_index = maxOrderIndex + 1 + newJobs.length;
                newJobs.push(job);
                successCount++;
            });
            if (newJobs.length > 0) {
                el('#db_status').textContent = `Importing ${newJobs.length} jobs...`;
                const { error } = await supabaseClient.from('jobs').insert(newJobs);
                if (error) throw new Error('Supabase insert failed: ' + error.message);
                state.jobs.push(...newJobs);
                el('#db_status').textContent = 'Database Synced';
            }
            let alertMsg = `นำเข้าสำเร็จ ${successCount} รายการ`;
            if (failCount > 0) alertMsg += `\nล้มเหลว ${failCount} รายการ (แถวที่: ${failedRows.join(', ')}).`;
            
            show('jobs');
            renderAll();
            alert(alertMsg);
        } catch (err) {
            alert(`เกิดข้อผิดพลาดในการนำเข้าไฟล์: ${err.message}`);
        } finally {
            el('#fileImportJobsXLSX').value = '';
        }
    };
    reader.readAsArrayBuffer(file);
}
el('#fileImportJobsXLSX').addEventListener('change', (e) => {
    if (e.target.files[0]) importJobsXLSX(e.target.files[0]);
});


// --- APP INITIALIZATION & REALTIME ---
const today = new Date().toISOString().slice(0,10);

function setupRealtimeSubscriptions() {
    console.log('Setting up realtime subscriptions...');
    
    const jobChannel = supabaseClient.channel('public:jobs');
    jobChannel.on('postgres_changes', { event: '*', schema: 'public', table: 'jobs' }, async (payload) => {
        if (isDragging) {
            console.log("Realtime update ignored during drag operation.");
            return;
        }
        console.log('Realtime job change received!', payload);
        const { data: jobsData, error: jobsError } = await supabaseClient.from('jobs').select('*').order('order_index');
        if (jobsError) { console.error('Realtime fetch error:', jobsError); return; }
        state.jobs = jobsData || [];
        renderAll();
    }).subscribe((status) => {
        if (status === 'SUBSCRIBED') console.log('Successfully subscribed to jobs channel!');
    });

    const settingsChannel = supabaseClient.channel('public:settings');
    settingsChannel.on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'settings' }, (payload) => {
        if (isDragging) return;
        console.log('Realtime settings change received!', payload);
        state.settings = payload.new.data;
        migrateSettingsForProcessTypes(state.settings);
        renderAll();
    }).subscribe();
}

async function initializeApp() {
    state = await load();
    [el('#f_date'), el('#d_date'), el('#dep_date')].forEach(input => input.value = today);
    renderAll();
    show('dash');
    setupRealtimeSubscriptions();
}

initializeApp();

</script>
</body>
</html>
